#!/usr/bin/env python3

from flask import Flask

#The Flask class constructor requires the name of the primary module to be interpreted as the application
#Flask uses this to figure out where the application IS and where its important files are
#Flask needs to set up an application structure that allows it to see everything

#note when we run, python server/app.py, the value of __name__ will be __main__. __name__ is always equal to the NAME OF THE MODULE IN QUESTION. 
app = Flask(__name__)


#clients send requests to our server. These requests get forwarded to our Flask application instance. These requests will be at different URLs. To handle these requests, we need to define routes. These routes map URLs to Python functions 

    #TLDR: routes associate a URL with the code that should execute when a request comes in for that URL. 

#The easiest way to define a route is through the @app.route decorator. Decorators are just functions that take functions as arguments and return them decorated with new features

#@app.route registers the index() method with the Flask application instance. The @app.route() decorator is an instance method that modifies app. What it does is, create a rule that says, "requests for the base URL(/) should show our index. A page with a header that says, Welcome to my app!"

#TLDR: the below registers the index() method with the application instance and its routes. Essentially we connect a VIEW to the application instance's ROUTES

@app.route('/') #this line tells Flask to show the returned data from index() in the web browser
def index():
    return '<h1>Welcome to my page!</h1>'

#Views are functions that map to URLs. Essentially everything you view from the browser is generated by a view. A view, returns a response that the client(their browser) delivers to the user. 


#the below parameterizes part of our route so that we can interpolate these into strings or even use them to retrieve records from a database
#anything with <> in the route, will be passed to the decorated function as a parameter. We can even strictly type our parameters to make sure the parameters are of the correct type.
@app.route('/<string:username>')
def user(username):
    return f'<h1>Profile for {username}</h1>'



#other
    #flask run is a command that look for the name of the Python module with our Flask application instance. To be able to do this, first we need to export our flask_app along with the module with our application as well as export the port our appliicatoin runs on. 
    #example:
        #export FLASK_APP = app.py
        #export FLASK_RUN_PORT=5555

#we can also run a development server by treating our application module as a script. To be able to do this, we'll use app.run()

if __name__ == '__main__':
    app.run(port=5555, debug=True)
    #debug=True restarts the server whenever a change is made to app.py